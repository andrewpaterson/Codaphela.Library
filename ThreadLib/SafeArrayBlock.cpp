#include "SafeArrayBlock.h"


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Init(size iElementSize)
{
	m.lock();
	c.Init(iElementSize);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Init(CMallocator* pcMalloc, size iElementSize)
{
	m.lock();
	c.Init(pcMalloc, iElementSize);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Init(CMallocator* pcMalloc, size iElementSize, size iChunkSize)
{
	m.lock();
	c.Init(pcMalloc, iElementSize, iChunkSize);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::ReInit(void)
{
	m.lock();
	c.ReInit();
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void  CSafeArrayBlock::Finalise(void)
{
	m.lock();
	c.Finalise();
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Kill(void)
{
	m.lock();
	c.Kill();
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::NumElements(void)
{
	return c.NumElements();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::IsEmpty(void)
{
	return c.IsEmpty();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::IsNotEmpty(void)
{
	return c.IsNotEmpty();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::AllocatedElements(void)
{
	return c.AllocatedElements();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::ElementSize(void)
{
	return c.ElementSize();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Add(void* pvData)
{
	m.lock();
	c.Add(pvData);
	m.unlock();

}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::AddGetIndex(void* pvData)
{
	size iIndex;

	m.lock();
	pvData = c.AddGetIndex(&iIndex);
	m.unlock();
	return iIndex;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::AddIfUnique(void* pvData)
{
	size iIndex;

	m.lock();
	iIndex = c.AddIfUnique(pvData);
	m.unlock();
	return iIndex;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::AddIfUniqueKey(void* pvData, size iKeyOffset, size iKeySize)
{
	size iIndex;

	m.lock();
	iIndex = c.AddIfUniqueKey(pvData, iKeyOffset, iKeySize);
	m.unlock();
	return iIndex;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Copy(CArrayBlock* pcTemplateArray)
{
	m.lock();
	c.Copy(pcTemplateArray);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Copy(CSafeArrayBlock* pcTemplateArray)
{
	CStackMemory<>	cTemp;
	size				iNumElements;

	iNumElements = pcTemplateArray->Copy(&cTemp);

	m.lock();
	c.Resize(iNumElements);

	memcpy(c.GetData(), cTemp.GetStackData(), iNumElements * c.ElementSize());
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::Copy(CStackMemory<>* pcTemp)
{
	size_t	iByteSize;
	void*	pv;
	size		iUsedElements;

	m.lock();
	iByteSize = c.ByteSize();
	iUsedElements = c.NumElements();
	pv = pcTemp->Init(iByteSize);
	memcpy(pv, c.GetData(), iByteSize);
	m.unlock();
	return iUsedElements;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::Get(size iIndex, void* pvDest)
{
	void*	pv;

	m.lock();
	pv = c.SafeGet(iIndex);
	return MemcpyDestAndUnlock(pv, pvDest);
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::Tail(void* pvDest)
{
	void* pv;

	m.lock();
	pv = c.Tail();
	return MemcpyDestAndUnlock(pv, pvDest);
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::InsertAt(void* pvData, size iIndex)
{
	m.lock();
	c.InsertAt(pvData, iIndex);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::InsertIntoSorted(int(*fCompare)(const void*, const void*), void* pvData, bool bOverwriteExisting)
{
	size iIndex;

	m.lock();
	iIndex = c.InsertIntoSorted(fCompare, pvData, bOverwriteExisting);
	m.unlock();

	return iIndex;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::Pop(void* pvDest)
{
	bool	bResult;

	m.lock();
	bResult = c.Pop(pvDest);
	m.unlock();

	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::Pop(void)
{
	bool	bResult;

	m.lock();
	bResult = c.Pop();
	m.unlock();

	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Push(void* pvData)
{
	m.lock();
	c.Push(pvData);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::PopFirst(void* pvDest)
{
	bool	bResult;

	m.lock();
	bResult = c.PopFirst(pvDest);
	m.unlock();

	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::PopFirst(void)
{
	bool	bResult;

	m.lock();
	bResult = c.PopFirst();
	m.unlock();

	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::Resize(size iNumElements)
{
	size	iOldUsedElements;

	m.lock();
	iOldUsedElements = c.Resize(iNumElements);
	m.unlock();

	return iOldUsedElements;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::BubbleSort(int(*fCompare)(const void*, const void*))
{
	m.lock();
	c.BubbleSort(fCompare);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::QuickSort(int(*fCompare)(const void*, const void*))
{
	m.lock();
	c.QuickSort(fCompare);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Reverse(void)
{
	m.lock();
	c.Reverse();
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::Contains(void* pvData)
{
	bool	bResult;

	m.lock();
	bResult = c.Contains(pvData);
	m.unlock();

	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::Find(void* pvData)
{
	size		iIndex;

	m.lock();
	iIndex = c.Find(pvData);
	m.unlock();

	return iIndex;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::FindInSorted(void* pvData, int(*fCompare)(const void*, const void*), size* piIndex)
{
	bool bResult;

	m.lock();
	bResult = c.FindInSorted(pvData, fCompare, piIndex);
	m.unlock();

	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::RemoveAt(size iIndex, bool bPreserveOrder)
{
	m.lock();
	c.RemoveAt(iIndex, bPreserveOrder);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::RemoveRange(size iStartIndex, size iEndIndexExclusive, bool bPreserveOrder)
{
	m.lock();
	c.RemoveRange(iStartIndex, iEndIndexExclusive, bPreserveOrder);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::RemoveTail(void)
{
	bool	bResult;

	m.lock();
	bResult = c.RemoveTail();
	m.unlock();

	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Set(size iIndex, void* pvData)
{
	m.lock();
	c.Set(iIndex, pvData);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Swap(size iIndex1, size iIndex2)
{
	m.lock();
	c.Swap(iIndex1, iIndex2);
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void CSafeArrayBlock::Zero(void)
{
	m.lock();
	c.Zero();
	m.unlock();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::ByteSize(void)
{
	return c.ByteSize();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::ChunkSize(void)
{
	return c.ChunkSize();
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
size CSafeArrayBlock::SetUsedElements(size iNumElements)
{
	size iOldUsedElements;

	m.lock();
	iOldUsedElements = c.SetUsedElements(iNumElements);
	m.unlock();

	return iOldUsedElements;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::SetChunkSize(size iChunkSize)
{
	bool	bResult;

	m.lock();
	bResult = c.SetChunkSize(iChunkSize);
	m.unlock();

	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::Write(CFileWriter* pcFileWriter)
{
	bool	bResult;

	m.lock();
	bResult = c.Write(pcFileWriter);
	m.unlock();

	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::Read(CFileReader* pcFileReader)
{
	bool	bResult;

	m.lock();
	bResult = c.Read(pcFileReader);
	m.unlock();

	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
bool CSafeArrayBlock::MemcpyDestAndUnlock(void* pvSource, void* pvDest)
{
	if (pvSource != NULL)
	{
		memcpy(pvDest, pvSource, c.ElementSize());
		m.unlock();
		return true;
	}
	else
	{
		m.unlock();
		return false;
	}
}

