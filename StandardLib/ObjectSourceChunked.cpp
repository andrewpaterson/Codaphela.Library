#include "BaseLib/ChunkFileFile.h"
#include "Objects.h"
#include "ObjectConverterNative.h"
#include "ObjectFileGeneral.h"
#include "ChunkFileObjectReader.h"
#include "ObjectSourceChunked.h"


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
bool CObjectSourceChunked::Init(CObjectConverter* pcConverter, CAbstractFile* pcFile, char* szFilename)
{
	CObjectSource::Init(pcConverter, pcFile, szFilename);

	mcChunkFile.Init(pcFile);
	mcChunkFileFileSystem.Init(&mcChunkFile);
	mcNames.Init();

	ReturnOnFalse(mcChunkFile.ReadOpen());
	ReturnOnFalse(ReadNames());

	mpcReader = NULL;
	return mcChunkFile.StackDepth() == 1;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CObjectSourceChunked::Kill(void)
{
	mcChunkFile.ReadClose();
	mcChunkFile.Kill();
	mcChunkFileFileSystem.Kill();

	mcNames.Kill();

	CObjectSource::Kill();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
bool CObjectSourceChunked::ReadNames(void)
{
	SChunkFilenameIterator	sIter;
	char*					szName;

	szName = mcChunkFileFileSystem.StartNameIteration(&sIter);
	while (szName)
	{
		if (!sIter.szValue.StartsWith(OBJECT_UNNAMED_FILE))
		{
			mcNames.Add(szName);
		}
		szName = mcChunkFileFileSystem.IterateName(&sIter);
	}
	mcChunkFileFileSystem.StopIteration(&sIter);


	mcNames.QuickSort(true);

	return true;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CBaseObject* CObjectSourceChunked::Convert(char* szFullName)
{
	CBaseObject*	pvObject;

	mpcReader = UMalloc(CChunkFileObjectReader);
	mpcReader->Init(&mcChunkFileFileSystem);

	pvObject = mpcConverter->Convert(this, szFullName);
	mpcReader->Kill();

	return pvObject;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
bool CObjectSourceChunked::Contains(char* szFullName)
{
	int		iIndex;

	iIndex = mcNames.FindInSorted(szFullName, false);
	return iIndex != -1;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
char* CObjectSourceChunked::GetName(int iIndex)
{
	return mcNames.Get(iIndex)->Text();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CObjectSourceChunked::NumNames(void)
{
	return mcNames.NumElements();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
bool CObjectSourceChunked::IsMultiSource(void)
{
	return true;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
bool CObjectSourceChunked::IsChunked(void)
{
	return true;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
bool CObjectSourceChunked::IsNative(void)
{
	return true; 
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CExternalObjectReader* CObjectSourceChunked::GetReader(void)
{
	return mpcReader;
}

