/** ---------------- COPYRIGHT NOTICE, DISCLAIMER, and LICENSE ------------- **

Copyright (c) 2012 Andrew Paterson

This file is part of The Codaphela Project: Codaphela StandardLib

Codaphela StandardLib is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Codaphela StandardLib is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Codaphela StandardLib.  If not, see <http://www.gnu.org/licenses/>.

** ------------------------------------------------------------------------ **/
#include "Object.h"
#include "HollowObject.h"
#include "ObjectDeserialiser.h"
#include "PointerObject.h"


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CPointer::CPointer()
{
	//Default Constructor.
	//Generally this should be avoided.

	mpcObject = NULL;
	mpcEmbedding = NULL;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CPointer::CPointer(CPointer& pcPointer)
{
	mpcEmbedding = pcPointer.mpcEmbedding;
	mpcObject = NULL;
	PointTo(pcPointer.mpcObject);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CPointer::CPointer(CEmbeddedObject* pcObject)
{
	mpcEmbedding = NULL;
	mpcObject = NULL;
	PointTo(pcObject);
}



//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CPointer::~CPointer()
{
	if (!mpcEmbedding)
	{
		if (mpcObject)
		{
			mpcObject->RemoveStackFrom();
		}
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::operator = (CEmbeddedObject* pcObject)
{
	//This operator override exists only to allow NULL assignment.
	PointTo(pcObject);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::operator = (CPointer& pcPointer)
{
	PointTo(pcPointer.mpcObject);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CEmbeddedObject* CPointer::operator -> ()
{
	if ((mpcObject) && (mpcObject->IsHollow()))
	{
		mpcObject = mpcObject->Dehollow();
	}
	return mpcObject;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CEmbeddedObject* CPointer::operator & ()
{
	if ((mpcObject) && (mpcObject->IsHollow()))
	{
		mpcObject = mpcObject->Dehollow();
	}
	return mpcObject;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CPointer::operator ! ()
{
	return mpcObject == NULL;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::ClearObject(void)
{
	mpcObject = NULL;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::SetEmbedding(CObject* pcEmbedding)
{
	mpcEmbedding = pcEmbedding;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::UnsafePointTo(CEmbeddedObject* pcNewObject)
{
	mpcObject = pcNewObject;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::PointTo(CEmbeddedObject* pcNewObject)
{
	CEmbeddedObject*	pcOldObject;

	if (mpcObject != pcNewObject)
	{
		pcOldObject = mpcObject;
		mpcObject = pcNewObject;

		if (mpcEmbedding)
		{			
			if (pcOldObject)
			{
				if (mpcObject)
				{
					mpcObject->AddFrom(mpcEmbedding);
				}
				pcOldObject->RemoveFrom(mpcEmbedding);
			}
			else if (mpcObject)
			{
				mpcObject->AddFrom(mpcEmbedding);
			}
		}
		else
		{
			if (pcOldObject)
			{
				pcOldObject->RemoveStackFrom();
			}

			if (mpcObject)
			{
				mpcObject->AddStackFrom();
			}
		}
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CPointer::IsNotNull(void)
{
	return mpcObject != NULL;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CPointer::IsNull(void)
{
	return mpcObject == NULL;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CPointer* CPointer::This(void)
{
	//This method should only *ever* be called whilst in the Load method on a CObject
	return this;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CEmbeddedObject* CPointer::Object(void)
{
	return mpcObject;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CEmbeddedObject** CPointer::ObjectPtr(void)
{
	return &mpcObject;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CBaseObject* CPointer::BaseObject(void)
{
	if (mpcObject && mpcObject->IsBaseObject())
	{
		return (CBaseObject*)mpcObject;
	}
	else
	{
		return NULL;
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CObject* CPointer::Embedding(void)
{
	return mpcEmbedding;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CEmbeddedObject* CPointer::Dereference(void)
{
	if ((mpcObject) && (mpcObject->IsHollow()))
	{
		mpcObject = mpcObject->Dehollow();
	}
	return mpcObject;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CPointer::RemapFrom(CEmbeddedObject* pcOld)
{
	int					iCount;
	int					iNumEmbeddedOld;
	CEmbeddedObject*	pcEmbeddedOld;
	int					iNumEmbeddedNew;
	int					iNumEmbedded;
	CEmbeddedObject*	pcEmbeddedNew;
	int					i;

	iNumEmbeddedNew = mpcObject->GetNumEmbedded();
	iNumEmbeddedOld = pcOld->GetNumEmbedded();

	iNumEmbedded = iNumEmbeddedNew;
	if (iNumEmbeddedOld < iNumEmbeddedNew)
	{
		iNumEmbedded = iNumEmbeddedOld;
	}

	iCount = 0;
	for (i = 0; i < iNumEmbedded; i++)
	{
		pcEmbeddedOld = pcOld->GetEmbeddedObject(i);
		pcEmbeddedNew = mpcObject->GetEmbeddedObject(i);

		iCount += RemapEmbeddedFrom(pcEmbeddedNew, pcEmbeddedOld);
	}

	return iCount;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CPointer::RemapEmbeddedFrom(CEmbeddedObject* pcNew, CEmbeddedObject* pcOld)
{
	int				iNumFroms;
	int				i;
	CBaseObject*	pvFrom;
	int				iCount;

	iCount = 0;

	iNumFroms = pcOld->CEmbeddedObject::NumHeapFroms();
	for (i = 0; i < iNumFroms; i++)
	{
		pvFrom = pcOld->PrivateGetFrom(i);
		iCount += pvFrom->RemapTos(pcOld, pcNew);
		pcNew->AddFrom(pvFrom);
	}

	pcNew->CopyFroms(pcOld);
	pcNew->SetDistToRoot(pcOld->DistToRoot());

	return iCount;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CPointer::IsHollow(void)
{
	if (mpcObject)
	{
		return mpcObject->IsHollow();
	}
	else
	{
		return FALSE;
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CPointer::Load(CObjectDeserialiser* pcFile)
{
	if (mpcObject)
	{
		if (!mpcObject->IsHollow())
		{
			return mpcObject->Load(pcFile);
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}
}



//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CPointer::DistToRoot(void)
{
	if (mpcObject)
	{
		return mpcObject->DistToRoot();
	}
	else
	{
		return -1;
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
OIndex CPointer::GetIndex(void)
{
	if (mpcObject)
	{
		return mpcObject->GetOI();
	}
	else
	{
		return NULL_O_INDEX;
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
char* CPointer::GetName(void)
{
	if (mpcObject && mpcObject->IsNamed())
	{
		return mpcObject->GetName();
	}
	else
	{
		return NULL;
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CPointer::IsNamed(void)
{
	if (mpcObject)
	{
		return mpcObject->IsNamed();
	}
	else
	{
		return FALSE;
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
char* CPointer::ClassName(void)
{
	if (mpcObject)
	{
		return mpcObject->ClassName();
	}
	else
	{
		return NULL;
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CPointer::IsDirty(void)
{
	if (mpcObject)
	{
		return mpcObject->IsDirty();
	}
	else
	{
		return FALSE;
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::Kill(void)
{
	//This method exists so that it's object can be killed without invoking -> and potentially loading it first.
	if (mpcObject)
	{
		return mpcObject->Kill();
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::ClearIndex(void)
{
	if (mpcObject)
	{
		mpcObject->ClearIndex();
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::AssignObject(CEmbeddedObject* pcObject)
{
	mpcObject = pcObject;
	mpcObject->AddStackFrom();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::Construct(CPointer& cPointer)
{
	mpcObject = cPointer.mpcObject;
	mpcEmbedding = cPointer.mpcEmbedding;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CPointer::AddFrom(CBaseObject* pcFrom)
{
	if (mpcObject)
	{
		mpcObject->AddFrom(pcFrom);
	}
}

