/** ---------------- COPYRIGHT NOTICE, DISCLAIMER, and LICENSE ------------- **

Copyright (c) 2025 Andrew Paterson

This file is part of The Codaphela Project: Codaphela GerberLib

Codaphela StandardLib is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Codaphela StandardLib is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Codaphela StandardLib.  If not, see <http://www.gnu.org/licenses/>.

** ------------------------------------------------------------------------ **/
#include "BaseLib/Logger.h"
#include "BaseLib/CalculatorParser.h"
#include "BaseLib/PointerFunctions.h"
#include "Instruction.h"
#include "W65C816State.h"
#include "W65C816.h"
#include "W65C816Func.h"


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::CW65C816::Init(CW65C816Pins* pcPins)
{
	mpcState = NewMalloc<CW65C816State>();
    mpcState->Init();

    mpcPins = pcPins;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::CW65C816::Kill(void)
{
	SafeKill(mpcState);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CW65C816State* CW65C816::GetState(void)
{
	return mpcState;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CW65C816Pins* CW65C816::GetPins(void)
{
    return mpcPins;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::CW65C816::Branch(bool condition)
{
    if (!condition)
    {
        mpcState->DoneInstruction();
    }
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ASL(void)
{
    mpcState->ASL();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ASL_A(void)
{
    mpcState->ASL_A();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PER(void)
{
    mpcState->PER();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PLD(void)
{
    mpcState->SetDirectPage(mpcState->GetData16Bit());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PHD(void)
{
    mpcState->PHD();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PLB(void)
{
    mpcState->SetDataBank(mpcState->GetDataLow());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PHB(void)
{
    mpcState->SetDataLow(mpcState->GetDataBank());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PHK(void)
{
    mpcState->SetDataLow(mpcState->GetProgramCounter()->GetBank());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PLP(void)
{
    mpcState->PLP();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PHP(void)
{
    mpcState->SetDataLow(mpcState->GetProcessorRegisterValue());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BRK(void)
{
    mpcState->SoftBreak();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::COP(void)
{
    mpcState->SoftBreak();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ORA(void)
{
    mpcState->ORA();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TSB(void)
{
    mpcState->TSB();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TRB(void)
{
    mpcState->TRB();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BPL(void)
{
    Branch(!mpcState->IsSignSet());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BMI(void)
{
    Branch(mpcState->IsSignSet());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::CLC(void)
{
    mpcState->SetCarryFlag(false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::INC_A(void)
{
    mpcState->INC_A();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TCS(void)
{
    mpcState->TCS();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::AND(void)
{
    mpcState->AND();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BIT(void)
{
    mpcState->BIT();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BIT_A(void)
{
    mpcState->BIT_A();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ROL(void)
{
    mpcState->ROL();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ROL_A(void)
{
    mpcState->ROL_A();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::SEC(void)
{
    mpcState->SetCarryFlag(true);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::DEC_A(void)
{
    mpcState->DEC_A();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TSC(void)
{
    mpcState->TSC();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::EOR(void)
{
    mpcState->EOR();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::WDM(void)
{
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::MVP(void)
{
    mpcState->BlockMovePrevious();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::MVN(void)
{
    mpcState->BlockMoveNext();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::LSR(void)
{
    mpcState->LSR();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PHA(void)
{
    mpcState->SetMemoryData(mpcState->GetA(), false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::LSR_A(void)
{
    mpcState->LSR_A();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BVC(void)
{
    Branch(!mpcState->IsOverflowSet());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::CLI(void)
{
    mpcState->SetInterruptDisableFlag(false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PHY(void)
{
    mpcState->SetIndexData(mpcState->GetY(), false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TCD(void)
{
    mpcState->TCD();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ADC(void)
{
    mpcState->ADC();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::STZ(void)
{
    mpcState->SetMemoryData(0);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PLA(void)
{
    mpcState->SetA(mpcState->GetMemoryData());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ROR(void)
{
    mpcState->ROR();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ROR_A(void)
{
    mpcState->ROR_A();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BVS(void)
{
    Branch(mpcState->IsOverflowFlag());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::SEI(void)
{
    mpcState->SetInterruptDisableFlag(true);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PLY(void)
{
    mpcState->SetY(mpcState->GetIndexData());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TDC(void)
{
    mpcState->SetC(mpcState->GetDirectPage());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BRA(void)
{
    Branch(true);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::STA(void)
{
    mpcState->SetMemoryData(mpcState->GetA(), false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::STY(void)
{
    mpcState->SetIndexData(mpcState->GetY(), false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::STX(void)
{
    mpcState->SetIndexData(mpcState->GetX(), false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::DEY(void)
{
    mpcState->DEY();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TXA(void)
{
    mpcState->TXA();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BCC(void)
{
    Branch(!mpcState->IsCarrySet());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::LDY(void)
{
    mpcState->LDY();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::LDA(void)
{
    mpcState->LDA();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::LDX(void)
{
    mpcState->LDX();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BCS(void)
{
    Branch(mpcState->IsCarrySet());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::CLV(void)
{
    mpcState->SetOverflowFlag(false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TSX(void)
{
    mpcState->TSX();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TYX(void)
{
    mpcState->SetX(mpcState->GetY());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TYA(void)
{
    mpcState->TYA();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TXS(void)
{
    mpcState->TXS();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TXY(void)
{
    mpcState->SetY(mpcState->GetX());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::CPY(void)
{
    mpcState->CPY();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::CMP(void)
{
    mpcState->CMP();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::REP(void)
{
    mpcState->REP();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TAY(void)
{
    mpcState->TAY();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::TAX(void)
{
    mpcState->TAX();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PHX(void)
{
    mpcState->SetIndexData(mpcState->GetX(), false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::STP(void)
{
    mpcState->mbStopped = true;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::DEC(void)
{
    mpcState->DEC();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::INY(void)
{
    mpcState->INY();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::DEX(void)
{
    mpcState->DEX();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BNE(void)
{
    Branch(!mpcState->IsZeroFlagSet());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::CLD(void)
{
    mpcState->SetDecimalFlag(false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::CPX(void)
{
    mpcState->CPX();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::SBC(void)
{
    mpcState->SBC();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::SEP(void)
{
    mpcState->SEP();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::INC(void)
{
    mpcState->INC();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::INX(void)
{
    mpcState->INX();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::NOP(void)
{
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::XBA(void)
{
    mpcState->XBA();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::BEQ(void)
{
    Branch(mpcState->IsZeroFlagSet());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::SED(void)
{
    mpcState->SetDecimalFlag(true);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::PLX(void)
{
    mpcState->SetX(mpcState->GetIndexData());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::XCE(void)
{
    mpcState->XCE();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ABORT(void)
{
    mpcState->SetInterruptDisableFlag(true);
    mpcState->SetDecimalFlag(false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::IRQ(void)
{
    mpcState->SetInterruptDisableFlag(true);
    mpcState->SetDecimalFlag(false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::NMI(void)
{
    mpcState->SetInterruptDisableFlag(true);
    mpcState->SetDecimalFlag(false);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::RES(void)
{
    mpcState->Reset();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::To8BitHexString(CChars* psz, uint8 ui8)
{
    psz->AppendHexHiLo(&ui8, 1);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::To16BitHexString(CChars* psz, uint16 ui16)
{
    psz->AppendHexHiLo(&ui16, 2);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::Append0x(CChars* psz, bool bAppend0x)
{
    if (bAppend0x)
    {
        psz->Append("0x");
    }
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ToAddressHexString(CChars* psz, CAddress* pcAddress, bool bAppend0x)
{
    uint16      ui16;
    uint8       ui8;

    ui16 = pcAddress->GetOffset();
    ui8 = pcAddress->GetBank();
    Append0x(psz, bAppend0x);
    To8BitHexString(psz, ui8);
    psz->Append(":");
    To16BitHexString(psz, ui16);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetAddressValueHex(CChars* psz, bool bAppend0x)
{
    ToAddressHexString(psz, mpcState->GetAddress(), bAppend0x);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetAccumulatorValueHex(CChars* psz, bool bAppend0x)
{
    Append0x(psz, bAppend0x);
    To16BitHexString(psz, mpcState->GetA());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetXValueHex(CChars* psz, bool bAppend0x)
{
    Append0x(psz, bAppend0x);
    To16BitHexString(psz, mpcState->GetX());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetYValueHex(CChars* psz, bool bAppend0x)
{
    Append0x(psz, bAppend0x);
    To16BitHexString(psz, mpcState->GetY());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetDataBankValueHex(CChars* psz, bool bAppend0x)
{
    Append0x(psz, bAppend0x);
    To8BitHexString(psz, mpcState->GetDataBank());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetStackValueHex(CChars* psz, bool bAppend0x)
{
    Append0x(psz, bAppend0x);
    To16BitHexString(psz, mpcState->GetStackPointer());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetDirectPageValueHex(CChars* psz, bool bAppend0x)
{
    Append0x(psz, bAppend0x);
    To16BitHexString(psz, mpcState->GetDirectPage());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetProgramCounterValueHex(CChars* psz, bool bAppend0x)
{
    ToAddressHexString(psz, mpcState->GetProgramCounter(), bAppend0x);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetDataValueHex(CChars* psz, bool bAppend0x)
{
    Append0x(psz, bAppend0x);
    To16BitHexString(psz, mpcState->GetData16Bit());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetOpcodeValueHex(CChars* psz, int cycle, CInstruction* pcInstruction, bool bAppend0x)
{
    uint16  uiCode;

    if (cycle != 0)
    {
        uiCode = pcInstruction->GetCode();
        if (uiCode <= 255)
        {
            Append0x(psz, bAppend0x);
            To8BitHexString(psz, (uint8)uiCode);
        }
        else
        {
            if (bAppend0x)
            {
                psz->Append("-----");
            }
            else
            {
                psz->Append("---");
            }
        }
    }
    else
    {
        if (bAppend0x)
        {
            psz->Append("#####");
        }
        else
        {
            psz->Append("###");
        }
    }
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetOpcodeValueHex(CChars* psz, bool bAppend0x)
{
    return GetOpcodeValueHex(psz, GetCycle(), mpcState->GetOpcode(), bAppend0x);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetOpcodeMnemonicString(CChars* psz)
{
    CInstruction*   pcInstruction;

    pcInstruction = mpcState->GetOpcode();
    if (pcInstruction)
    {

        psz->Append(pcInstruction->GetName());
    }
    else
    {
        psz->Append("---");
    }
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetCycleOperationString(CChars* psz)
{
    CBusCycle*          pcBusCycle;
    CDataOperation*     pcDataOperation;

    pcBusCycle = mpcState->GetBusCycle();
    if (pcBusCycle)
    {
        pcDataOperation = pcBusCycle->GetDataOperation();
        pcDataOperation->Print(psz);
    }
    else
    {
        psz->Append("---");
    }
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetStatusString(CChars* psz)
{
    bool emulation = mpcState->IsEmulation();

    mpcState->IsZeroFlagSet() ? psz->Append("Z1 ") : psz->Append("Z0 ");
    mpcState->IsNegativeSet() ? psz->Append("N1 ") : psz->Append("N0 ");
    mpcState->IsDecimal() ? psz->Append("D1 ") : psz->Append("D0 ");
    mpcState->IsInterruptDisable() ? psz->Append("I1 ") : psz->Append("I0 ");
    mpcState->IsMemory8Bit() ? psz->Append("M8  ") : psz->Append("M16 ");
    mpcState->IsIndex8Bit() ? psz->Append("X8  ") : psz->Append("X16 ");
    mpcState->IsCarrySet() ? psz->Append("C1 ") : psz->Append("C0 ");
    emulation ? psz->Append("E1 ") : psz->Append("E0 ");
    if (!emulation)
    {
        mpcState->IsOverflowFlag() ? psz->Append("O1") : psz->Append("O0");
    }
    else
    {
        mpcState->IsOverflowFlag() ? psz->Append("O1 ") : psz->Append("O0 ");
        mpcState->IsBreak() ? psz->Append("B1") : psz->Append("B0");
    }
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
char* CW65C816::GetType(void)
{
    return "W65C816 Microprocessor";
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::GetCycleString(CChars* psz)
{
    psz->Append(GetCycle());
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int16 CW65C816::GetCycle(void)
{
    return mpcState->GetCycle() + 1;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
bool CW65C816::IsStopped(void)
{
    return mpcState->IsStopped();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::DisableBuses(void)
{
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::InputTransition(CTimeline* pcTimeline)
{
    CW65C816Pins*   pcPins;
    bool            bReset;
    bool            bNmi;
    bool            bIrq;
    bool            bAbort;
    STraceValue     sClockValue;

    pcPins = GetPins();
    sClockValue = pcPins->ReadPhi2(pcTimeline);
    bReset = pcPins->ReadRES(pcTimeline).IsLow();
    if (bReset || mpcState->IsReseting(sClockValue))
    {
        mpcState->ResetPulled();
    }
    else
    {
        mpcState->ClearReset();
    }

    bNmi = pcPins->ReadNMI(pcTimeline).IsLow();
    bIrq = pcPins->ReadIRQ(pcTimeline).IsLow();
    bAbort = pcPins->ReadAbort(pcTimeline).IsLow();

    mpcState->mbBusEnable = pcPins->ReadBE(pcTimeline).IsHigh();
    if (!mpcState->IsBusEnable())
    {
        DisableBuses();
    }

    if (sClockValue.IsHigh() || sClockValue.IsLow())
    {
        bool risingEdge = sClockValue.IsHigh() && mpcState->mbPreviousClockLow;
        bool fallingEdge= sClockValue.IsLow() && mpcState->mbPreviousClockHigh;

        mpcState->mbPreviousClockLow = sClockValue.IsLow();
        mpcState->mbPreviousClockHigh = sClockValue.IsHigh();

        if (!mpcState->IsStopped())
        {
            if (fallingEdge)
            {
                ExecutPhi2Falling(pcTimeline);
            }

            if (risingEdge)
            {
                ExecutPhi2Rising(pcTimeline);
            }
        }
    }

    mpcState->mbIrq = bIrq;

    //These don't look properly edge triggered.
    mpcState->mbNmi = bNmi;
    mpcState->mbAbort = bAbort;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ExecutPhi2Falling(CTimeline* pcTimeline)
{
    CBusCycle*          pcBusCycle;
    bool                bRead;
    CAddress            cAddress;
    CW65C816Pins*       pcPins;
    CDataOperation*     pcDataOperation;

    pcPins = GetPins();
    pcDataOperation = mpcState->GetDataOperation();
    if (pcDataOperation)
    {
        bRead = pcDataOperation->IsRead();

        if (bRead)
        {
            //Data on the data pins is READ on PHI falling
            mpcState->SetDataLow(pcPins->ReadData(pcTimeline));
        }

        mpcState->ExecuteTrailingSideOperation(this);
    }

    mpcState->Cycle(this);

    pcDataOperation = mpcState->GetDataOperation();
    if (pcDataOperation)
    {
        pcBusCycle = mpcState->GetBusCycle();
        bRead = pcDataOperation->IsRead();

        mpcState->ExecuteInitialSideOperation(this);

        pcBusCycle->GetAddress(&cAddress, this);

        //All signals are written 10ns after PHI falling.  Including the Bank on the data pins.
        //If the write doesn't take that into account then it is okay that is is instaneous after the read.
        pcPins->WriteRWB(pcTimeline, bRead);
        pcPins->WriteMX(pcTimeline, mpcState->IsIndex8Bit());
        pcPins->WriteVDA(pcTimeline, pcDataOperation->IsValidDataAddress());
        pcPins->WriteVPA(pcTimeline, pcDataOperation->IsValidProgramAddress());
        pcPins->WriteMLB(pcTimeline, pcDataOperation->IsNotMemoryLock());
        pcPins->WriteVPB(pcTimeline, pcDataOperation->IsNotVectorPull());
        pcPins->WriteE(pcTimeline, mpcState->IsEmulation());
        pcPins->WriteRdy(pcTimeline, pcDataOperation->IsReady());
        pcPins->WriteAddress(pcTimeline, cAddress.GetOffset());
        pcPins->WriteData(pcTimeline, cAddress.GetBank());
    }
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CW65C816::ExecutPhi2Rising(CTimeline* pcTimeline)
{
    CW65C816Pins*       pcPins;
    CDataOperation*     pcDataOperation;
    bool                bRead;

    pcPins = GetPins();

    pcDataOperation = mpcState->GetDataOperation();
    if (pcDataOperation)
    {
        bRead = pcDataOperation->IsRead();

        pcPins->WriteMX(pcTimeline, mpcState->IsMemory8Bit());

        if (!bRead)
        {
            pcPins->WriteData(pcTimeline, mpcState->GetDataLow());
        }
    }
}

