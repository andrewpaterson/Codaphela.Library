/** ---------------- COPYRIGHT NOTICE, DISCLAIMER, and LICENSE ------------- **

Copyright (c) 2012 Andrew Paterson

This file is part of The Codaphela Project: Codaphela BaseLib

Codaphela BaseLib is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Codaphela BaseLib is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Codaphela BaseLib.  If not, see <http://www.gnu.org/licenses/>.

Microsoft Windows is Copyright Microsoft Corporation

** ------------------------------------------------------------------------ **/
#include "Numbers.h"
#include "DatasIO.h"
#include "FloatHelper.h"
#include "DataIO.h"
#include "Double3.h"
#include "Double2.h"


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2::SDouble2(const double *pf)
{
	x = pf[0];
	y = pf[1];
}

SDouble2::SDouble2(double fx, double fy)
{
	x = fx;
	y = fy;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2& SDouble2::operator += (const SDouble2& v)
{
	x += v.x;
	y += v.y;
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2& SDouble2::operator -= (const SDouble2& v)
{
	x -= v.x;
	y -= v.y;
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2& SDouble2::operator *= (double f)
{
	x *= f;
	y *= f;
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2& SDouble2::operator /= (double f)
{
	double fInv = 1.0f / f;
	x *= fInv;
	y *= fInv;
	return *this;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2 SDouble2::operator + () const
{
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2 SDouble2::operator - () const
{
	return SDouble2(-x, -y);
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2 SDouble2::operator + (const SDouble2& v) const
{
	return SDouble2(x + v.x, y + v.y);
}

//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2 SDouble2::operator - (const SDouble2& v) const
{
	return SDouble2(x - v.x, y - v.y);
}

//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2 SDouble2::operator * (double f) const
{
	return SDouble2(x * f, y * f);
}

//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2 SDouble2::operator / (double f) const
{
	double fInv = 1.0f / f;
	return SDouble2(x * fInv, y * fInv);
}

//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2 operator * (double f, const SDouble2& v)
{
	return SDouble2(f * v.x, f * v.y);
}

//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
BOOL SDouble2::operator == (const SDouble2& v) const
{
	return x == v.x && y == v.y;
}

//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
BOOL SDouble2::operator != (const SDouble2& v) const
{
	return x != v.x || y != v.y;
}




//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void SDouble2::Init(double x, double y)
{
	this->x = x;
	this->y = y;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void SDouble2::Init(int x, int y)
{
	this->x = (double)x;
	this->y = (double)y;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void SDouble2::Zero(void)
{
	x = 0.0f;
	y = 0.0f;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
BOOL SDouble2::Save(CFileWriter* pcFile)
{
	BOOL bResult;

	bResult = pcFile->WriteFloat(x);
	bResult &= pcFile->WriteFloat(y);
	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
BOOL SDouble2::Load(CFileReader* pcFile)
{
	BOOL bResult;

	bResult = pcFile->ReadFloat(&x);
	bResult &= pcFile->ReadFloat(&y);
	return bResult;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void SDouble2::Fix(void)
{
	x = RoundDouble(x, BINARY_PRECISION);
	y = RoundDouble(y, BINARY_PRECISION);
}



//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
void SDouble2::Dump(void)
{
	CChars		sz;
	CChars		sx;
	int			iWidth;
	int			iDecimals;

	iWidth = 6;
	iDecimals = iWidth-5;
	sx.Init();
	sx.Append('[');
	sz.Init();
	sz.Append(x, iDecimals);
	sz.RightAlign(' ', iWidth);
	sx.Append(sz);
	sz.Kill();
	sx.Append(',');
	sz.Init();
	sz.Append(y, iDecimals);
	sz.RightAlign(' ', iWidth);
	sx.Append(sz);
	sz.Kill();
	sx.Append((char*)"]\n");
	sx.Dump();
	sx.Kill();
}




//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
double Double2Length(const SDouble2 *pV)
{
	return sqrt(pV->x * pV->x + pV->y * pV->y);
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
double Double2LengthSq(const SDouble2 *pV)
{
	return pV->x * pV->x + pV->y * pV->y;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
double Double2Dot(const SDouble2 *pV1, const SDouble2 *pV2)
{
	return pV1->x * pV2->x + pV1->y * pV2->y;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
double Double2CCW(const SDouble2 *pV1, const SDouble2 *pV2)
{
	return pV1->x * pV2->y - pV1->y * pV2->x;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2* Double2Add(SDouble2 *pOut, const SDouble2 *pV1, const SDouble2 *pV2)
{
	pOut->x = pV1->x + pV2->x;
	pOut->y = pV1->y + pV2->y;
	return pOut;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2* Double2Subtract(SDouble2 *pOut, const SDouble2 *pV1, const SDouble2 *pV2)
{
	pOut->x = pV1->x - pV2->x;
	pOut->y = pV1->y - pV2->y;
	return pOut;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2* Double2Minimize(SDouble2 *pOut, const SDouble2 *pV1, const SDouble2 *pV2)
{
	pOut->x = pV1->x < pV2->x ? pV1->x : pV2->x;
	pOut->y = pV1->y < pV2->y ? pV1->y : pV2->y;
	return pOut;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2* Double2Maximize(SDouble2 *pOut, const SDouble2 *pV1, const SDouble2 *pV2)
{
	pOut->x = pV1->x > pV2->x ? pV1->x : pV2->x;
	pOut->y = pV1->y > pV2->y ? pV1->y : pV2->y;
	return pOut;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2* Double2Scale(SDouble2 *pOut, const SDouble2 *pV, double s)
{
	pOut->x = pV->x * s;
	pOut->y = pV->y * s;
	return pOut;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
SDouble2* Double2Lerp(SDouble2 *pOut, const SDouble2 *pV1, const SDouble2 *pV2, double s)
{
	pOut->x = pV1->x + s * (pV2->x - pV1->x);
	pOut->y = pV1->y + s * (pV2->y - pV1->y);
	return pOut;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Double2Assign(SDouble2* psVecDest, double x, double y)
{
	psVecDest->x = x;
	psVecDest->y = y;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Double2Assign(SDouble2* psVecDest, SDouble2* psVecSource)
{
	psVecDest->x = psVecSource->x;
	psVecDest->y = psVecSource->y;
}


//////////////////////////////////////////////////////////////////////////
//																		//
//																		//
//////////////////////////////////////////////////////////////////////////
double Deg2Dot(double fDegrees)
{
	SDouble2	s1;
	SDouble2	s2;
	double	fRad;

	s1.Init(1.0f, 0.0f);
	fRad = Deg2Rad(fDegrees);
	s2.Init(cos(fRad), sin(fRad));

	return Double2Dot(&s1, &s2);
}
