#include "MemoryCacheAllocation.h"


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CMemoryCacheAllocation::Init(int iDataSize)
{
	mapEvictedCacheDescriptors.Init(256);
	miDataSize = iDataSize;
	
	mpsCacheDesc = NULL;
	miCachedSize = 0;
	miRemaining = 0;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CMemoryCacheAllocation::Kill(void)
{
	mapEvictedCacheDescriptors.Kill();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CMemoryCacheAllocation::HasOverlaps(void)
{
	return mapEvictedCacheDescriptors.IsNotEmpty();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
SMemoryCacheDescriptor* CMemoryCacheAllocation::Get(int iIndex)
{
	return (SMemoryCacheDescriptor*)mapEvictedCacheDescriptors.GetPtr(iIndex);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CMemoryCacheAllocation::NumElements(void)
{
	return mapEvictedCacheDescriptors.NumElements();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CArrayIntAndPointer* CMemoryCacheAllocation::GetEvictedArray(void)
{
	return &mapEvictedCacheDescriptors;
}

