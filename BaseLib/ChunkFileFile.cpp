#include "ChunkFile.h"
#include "ChunkFileFile.h"


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CChunkFileFile::Init(CChunkFile* pcChunkFile)
{
	CAbstractFile::Init();
	mpcChunkFile = pcChunkFile;
	miChunkStart = 0;
	miChunkSize = 0;
	mbEndOfFile = TRUE;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CChunkFileFile::Kill(void)
{
	mpcChunkFile = NULL;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CChunkFileFile::Open(EFileMode eMode)
{
	if (eMode == EFM_Read)
	{
		miChunkSize = mpcChunkFile->ChunkSize();
		miChunkStart = mpcChunkFile->ChunkStart();
		mbEndOfFile = FALSE;
		return TRUE;
	}

	return FALSE;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CChunkFileFile::Close(void)
{
	miChunkStart = 0;
	miChunkSize = 0;
	mbEndOfFile = TRUE;
	return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
filePos CChunkFileFile::Read(void* pvBuffer, filePos iSize, filePos iCount)
{
	filePos		iRemain;
	filePos		iReadSize;

	iRemain = Tell();
	iRemain = miChunkSize - iRemain;

	iReadSize = iSize * iCount;

	if (iRemain >= iReadSize)
	{
		return mpcChunkFile->Read(pvBuffer, iSize, iCount);
	}
	else
	{
		iCount = iRemain / iSize;
		mbEndOfFile = TRUE;
		return mpcChunkFile->Read(pvBuffer, iSize, iCount);
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CChunkFileFile::Seek(filePos iOffset, EFileSeekOrigin iSeekOrigin)
{
	if (iSeekOrigin == EFSO_SET)
	{
		if (iOffset < 0)
		{
			iOffset = 0;
		}
		if (iOffset > miChunkSize)
		{
			iOffset = miChunkSize;
		}

		mbEndOfFile = FALSE;
		return mpcChunkFile->Seek(miChunkStart + iOffset, EFSO_SET);
	}

	return FALSE;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
filePos CChunkFileFile::Write(const void* pvBuffer, filePos iSize, filePos iCount)
{
	return 0;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
filePos CChunkFileFile::Tell(void)
{
	filePos iPos;

	iPos = mpcChunkFile->GetFilePos();
	iPos -= miChunkStart;

	if (iPos > miChunkSize)
	{
		iPos = miChunkSize;
	}

	return iPos;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CChunkFileFile::Eof(void)
{
	return mbEndOfFile;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CChunkFileFile::IsOpen(void)
{
	return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
filePos CChunkFileFile::Size(void)
{
	return miChunkSize;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CChunkFileFile::Flush(void)
{
	return FALSE;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CChunkFileFile::Delete(void)
{
	return FALSE;
}

