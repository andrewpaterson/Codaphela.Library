/** ---------------- COPYRIGHT NOTICE, DISCLAIMER, and LICENSE ------------- **

Copyright (c) 2009 Andrew Paterson

This file is part of The Codaphela Project: Codaphela BaseLib

Codaphela BaseLib is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Codaphela BaseLib is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Codaphela BaseLib.  If not, see <http://www.gnu.org/licenses/>.

Microsoft Windows is Copyright Microsoft Corporation

** ------------------------------------------------------------------------ **/
#include "AdditionalTypes.h"


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArraySimpleInt::Add(int i)
{
	int*	pi;

	pi = __CArraySimpleInt::Add();
	*pi = i;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CArraySimpleInt::AddIfUnique(int i)
{
	int iElementNum;

	iElementNum = Find(i);
	if (iElementNum == -1)
	{
		Add(i);
	}
	return iElementNum;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CArraySimpleInt::Find(int i)
{
	int	j;

	for (j = 0; j < miUsedElements; j++)
	{
		if (*Get(j) == i)
		{
			return j;
		}
	}
	return -1;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CArraySimpleInt::GetValue(int iElementPos)
{
	return *Get(iElementPos);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArraySimpleInt::QuickSort(void)
{
	__CArraySimpleInt::QuickSort(&ComparePrimitive<int>);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArrayOfArraySimpleInt::Allocate(int iChunkSize)
{
	__CArrayOfArraySimpleInt::Allocate(iChunkSize);
	InitArrays(0, miUsedElements);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArrayOfArraySimpleInt::Allocate(int iChunkSize, int iNumElements)
{
	__CArrayOfArraySimpleInt::Allocate(iChunkSize, iNumElements);
	InitArrays(0, miUsedElements);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArrayOfArraySimpleInt::Kill(void)
{
	int					i;
	CArraySimpleInt*	pcArrayInt;

	pcArrayInt = (CArraySimpleInt*)mpvArray;
	for (i = 0; i < miUsedElements; i++)
	{
		pcArrayInt[i].Kill();
	}
	__CArrayOfArraySimpleInt::Kill();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArrayOfArraySimpleInt::InitArrays(int iStartIndex, int iEndIndex)
{
	int					i;
	CArraySimpleInt*	pcArray;

	pcArray = Get(0);
	for (i = iStartIndex; i < iEndIndex; i++)
	{
		pcArray[i].Init();
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CArraySimpleInt* CArrayOfArraySimpleInt::Add(void)
{
	CArraySimpleInt*	pcArrayInt;

	pcArrayInt = __CArrayOfArraySimpleInt::Add();
	pcArrayInt->Init();

	return pcArrayInt;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArrayOfArrayInt::Kill(void)
{
	int			i;
	CArrayInt*	pcArrayInt;

	pcArrayInt = (CArrayInt*)mpvArray;
	for (i = 0; i < miUsedElements; i++)
	{
		pcArrayInt->Kill();
	}
	__CArrayOfArrayInt::Kill();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CArrayInt* CArrayOfArrayInt::Add(void)
{
	CArrayInt*	pcArrayInt;

	pcArrayInt = __CArrayOfArrayInt::Add();
	pcArrayInt->Init();

	return pcArrayInt;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CArrayInt* CArrayOfArrayInt::Add(int iChunkSize)
{
	CArrayInt*	pcArrayInt;

	pcArrayInt = __CArrayOfArrayInt::Add();
	pcArrayInt->Init(iChunkSize);

	return pcArrayInt;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CArrayOfArrayInt::AddIfUnique(CArrayInt* pacArrayInt)
{
	CArrayInt*	pacNew;
	int			i;

	i = Find(pacArrayInt);
	if (i != -1)
	{
		return i;
	}
	pacNew = Add();
	pacNew->Copy(pacArrayInt);
	return -1;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CArrayOfArrayInt::Find(CArrayInt* pacArrayInt)
{
	CArrayInt*	pacCompare;

	for (int i = 0; i < miUsedElements; i++)
	{
		pacCompare = Get(i);
		if (pacArrayInt->Equals(pacCompare))
		{
			return i;
		}
	}
	return -1;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CTypedArrayInt::Init(void)
{
	CArrayInt::Init();
	miType = -1;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CTypedArrayInt::Init(int iChunkSize)
{
	CArrayInt::Init(iChunkSize);
	miType = -1;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CTypedArrayInt::SetType(int iType)
{
	miType = iType;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
int CTypedArrayInt::GetType(void)
{
	return miType;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArrayOfTypedArrayInt::Init(void)
{
	__CArrayOfTypedArrayInt::Init();
	miDefaultChunkSize = 1;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArrayOfTypedArrayInt::Init(int iChunkSize)
{
	__CArrayOfTypedArrayInt::Init(iChunkSize);
	miDefaultChunkSize = iChunkSize;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArrayOfTypedArrayInt::Init(int iChunkSizeMajor, int iChunkSizeMinor)
{
	__CArrayOfTypedArrayInt::Init(iChunkSizeMajor);
	miDefaultChunkSize = iChunkSizeMinor;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArrayOfTypedArrayInt::Kill(void)
{
	int				i;
	CTypedArrayInt*	pcArrayInt;

	pcArrayInt = (CTypedArrayInt*)mpvArray;
	for (i = 0; i < miUsedElements; i++)
	{
		pcArrayInt->Kill();
	}
	miDefaultChunkSize = 0;
	__CArrayOfTypedArrayInt::Kill();
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CTypedArrayInt*	CArrayOfTypedArrayInt::AddArray(int iType)
{
	CTypedArrayInt*	pcArrayInt;

	pcArrayInt = __CArrayOfTypedArrayInt::Add();
	pcArrayInt->Init(miDefaultChunkSize);
	pcArrayInt->SetType(iType);

	return pcArrayInt;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void CArrayOfTypedArrayInt::AddElement(int iType, int iValue)
{
	CTypedArrayInt*		pai;

	pai = GetArray(iType);
	if (!pai)
	{
		pai = AddArray(iType);
	}
	pai->Add(iValue);
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
CTypedArrayInt* CArrayOfTypedArrayInt::GetArray(int iType)
{
	int					i;
	CTypedArrayInt*		pai;

	for (i = 0; i < miUsedElements; i++)
	{
		pai = Get(i);
		if (pai->miType == iType)
		{
			return pai;
		}
	}
	return NULL;
}
